package archivos.jflexyjcup;

import archivos.jflexyjcup.ast.Base.Constantes.*;
import archivos.jflexyjcup.ast.Base.*;
import archivos.jflexyjcup.ast.Sentencias.Displays.*;
import archivos.jflexyjcup.ast.Sentencias.Inputs.*;
import archivos.jflexyjcup.ast.Operaciones.binarias.*;
import archivos.jflexyjcup.ast.Operaciones.binarias.arismeticos.*;
import archivos.jflexyjcup.ast.Operaciones.binarias.comparaciones.*;
import archivos.jflexyjcup.ast.Operaciones.binarias.logicas.*;
import archivos.jflexyjcup.ast.Operaciones.unarias.conversiones.*;
import archivos.jflexyjcup.ast.Operaciones.unarias.*;
import archivos.jflexyjcup.ast.Sentencias.*;
import archivos.jflexyjcup.ast.Sentencias.SentenciaInteraciones.*;
import archivos.jflexyjcup.ast.Sentencias.SentenciaSeleccion.*;
import com.google.common.collect.ArrayListMultimap;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Hashtable;
import com.google.common.collect.Multimap;
import java_cup.runtime.XMLElement;

class MiParser;


action code {:
    Hashtable tablaSimbolo = new Hashtable();
    //Multimap<String, String> tablaSimbolos2 = ArrayListMultimap.create();
    //public Multimap getTabladeSimbolos(){
     //       return tablaSimbolos2;
   // }


    //public String simbolos;

:};

parser code
{:
    public void syntax_error(Symbol s) {
                    if (s.sym==32){
                                concat_rules("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
                                        +s.value+"' . Simbolo n째 "+s.sym);
                        try {
                            throw new Exception((String) s.value);
                        } catch (Exception e) {

                        }
                    }
                            else
                            {concat_rules("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
                                    +s.value+"' . Simbolo n째 "+s.sym+ " no reconocido." );}
            }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        if (s.sym == 32){
            throw  new Exception("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
                    +s.value+"' . Simbolo n째 "+s.sym+ "" );
        }
        else
                                    {throw new Exception("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
                                            +s.value+"' . Simbolo n째 "+s.sym+ " no reconocido." ); }
    }

    public String reglas;

    public void concat_rules(String regla){
        reglas += regla + "\n\n";
    }

    public String simbolos;

    Multimap<String, String> tablaSimbolos2 = ArrayListMultimap.create();
    public Multimap getTabladeSimbolos(){
                return tablaSimbolos2;
        }

   public Tipo checkTipos(Tipo t1,Tipo t2) throws Exception
       {
           if (t1 == t2){
               return t1;
           }
           if (t1 ==Tipo.Float && t2 ==Tipo.Int ) {
               return t2;
           }
           throw new Exception("Tipos no compatibles.");
       }
:};

terminal SUMA,RESTA,MULT,DIV, ASIGN, PARENTESISO, PARENTESISC, CORCHETEO, CORCHETEC, PUNTOCOMA,
COMA, DOSPUNTOS, DISPLAY, WHILE, DO, INPUT_INT, INPUT_FLOAT,INPUT_BOOL, IF, THEN, ELSE, END, AND, OR, NOT, MAYOR,MENOR,IGUAL,DISTINTO,MAYOR_IGUAL,MENOR_IGUAL, COLA, ERROR,TIPO_INT, TIPO_FLOAT, TIPO_BOOL;
terminal String STRING_LITERAL,BOOL, INT, FLOAT, IDENTIFIER,DECLARE_SECTION, ENDDECLARE_SECTION, PROGRAM_SECTION, ENDPROGRAM_SECTION;

nonterminal Nodo program;
nonterminal Programa programa;
nonterminal Tipo tipo_de_dato;
nonterminal Sentencia sentencia, sentencia_if, sentencia_display;
nonterminal List<Sentencia> lista_sentencias;
nonterminal While sentencia_while;
nonterminal Asignacion sentencia_asignacion;
nonterminal IfSimple if_simple;
nonterminal IfElse if_else;
nonterminal Expresion expresion, factor, menos_unario, termino, comparacion, exp_or,exp_and,exp_not, funcion_especial,pivot;
nonterminal String ids, sector_declaraciones,lista_declaraciones, declaracion;
nonterminal List<Expresion> lista_expresiones;
//precedence left OPCOMP, sentencia;

start with program;

program ::= sector_declaraciones:sd programa:p //programa
    {:  concat_rules("REGLA 0: program --> sector_declaraciones programa" + "\n\t --> " + sd + " " + p + " ");
    RESULT = p;
    //RESULT= sd + p ;
    :}
    |
    programa:p {:
    concat_rules("REGLA 0.1: program --> programa " + "\n\t --> " + p );
    RESULT = p;
    :}
    |;
sector_declaraciones ::= DECLARE_SECTION lista_declaraciones:ld ENDDECLARE_SECTION
    {: concat_rules("REGLA 1: sector_declaraciones --> DECLARE_SECTION lista_declaraciones ENDDECLARE_SECTION " + "\n\t --> " + "declare.section" + " " + ld + " " + "enddeclare.section" );
       RESULT = "DECLARE_SECTION" + ld + "ENDDECLARE_SECTION"; :};

lista_declaraciones ::= declaracion:d {:
    concat_rules ( "REGLA 1.1: lista_declaraciones --> declaracion " + "\n\t --> " + d + " ");
    RESULT = d; :}
    |
    lista_declaraciones:ld declaracion:d {:
    concat_rules ("REGLA 1.2: lista_declaraciones --> lista_declaraciones declaracion " + "\n\t --> " + " " + ld + d );
    RESULT = ld + d ; :};

declaracion ::= //no es necesario generar el nodo este.
    tipo_de_dato:td DOSPUNTOS ids:i PUNTOCOMA {:
        concat_rules("REGLA 2: declaracion --> tipo_de_dato DOSPUNTOS ids PUNTOCOMA " + "\n\t --> " + td + ": " + i + "; ");
        RESULT = td + ":" + i + ";";
        if (i.contains(",")){
                    String[] parts = i.split(",");
                    for (String s : parts){
                        tablaSimbolos2.put(s,td.name());
                }}
                else{
                        tablaSimbolos2.put(i, td.name());
                    }
        simbolos = tablaSimbolos2.toString() + "\n\n";
        //RESULT = new DeclaracionVariable( id, td) ; PREGUNTAR ESO
        :};

ids ::=
    IDENTIFIER:id {:
        concat_rules("REGLA 2.2: ids --> IDENTIFIER " + "\n\t --> " + id);
        RESULT = id; :}
    |
    ids:i COMA IDENTIFIER:id {:
        concat_rules("REGLA 2.2: ids --> ids IDENTIFIER " + "\n\t --> " + i + ", "+ id);
        RESULT = i + "," + id; :};

tipo_de_dato ::=
    TIPO_INT:ti {:
        concat_rules("REGLA 2.2.1: tipo_de_dato --> TIPO_INT " + "\n\t --> " + ti);
        //concat_rules("Regla 2.2.1: tipo_de_dato -->" + ti );
        RESULT = Tipo.Int; :}
    |
    TIPO_FLOAT:tf {:
        concat_rules("REGLA 2.2.2: tipo_de_dato --> TIPO_FLOAT " + "\n\t --> " + tf);
        //concat_rules("Regla 2.2.2: tipo_de_dato -->" + tf );
        RESULT = Tipo.Float; :}
    |
    TIPO_BOOL:tb {:
        concat_rules("REGLA 2.2.3: tipo_de_dato --> TIPO_BOOL " + "\n\t --> " + tb);
        //concat_rules("Regla 2.2.3: tipo_de_dato --> "+ tb);
        RESULT = Tipo.Bool;:};

programa ::=
        PROGRAM_SECTION lista_sentencias:ls ENDPROGRAM_SECTION {:
            concat_rules("REGLA 3: programa --> PROGRAM_SECTION lista_sentencias ENDPROGRAM_SECTION " + "\n\t --> " + "program.section " + ls  + " endprogram.section");
            //concat_rules("Regla 3: programa --> program.section " + ls  + " endprogram.section");
            //RESULT = "PROGRAM_SECTION" + ls + "ENDPROGRAM_SECTION";
            RESULT = new Programa("Programa", tablaSimbolos2, ls);

        :};

lista_sentencias ::=
        sentencia:s {:
            concat_rules("REGLA 3.1: lista_sentencias --> sentencia " + "\n\t --> " + s + " ");
            //concat_rules("Regla 3.1: lista_sentencias --> "  + s);
            List<Sentencia> lista_sentencias = new ArrayList<>();
            lista_sentencias.add(s);
            RESULT = lista_sentencias; :}
        |
        lista_sentencias:ls sentencia:s {:
            concat_rules("REGLA 3.2: lista_sentencias --> lista_sentencias sentencia " + "\n\t --> " + ls + " " + s + " ");
            //concat_rules("Regla 3.2: lista_sentencias --> " + ls + s);
            ls.add(s);
            RESULT = ls; :};

sentencia ::=
        sentencia_while:sw {:
            concat_rules("REGLA 3.1.1: sentencia --> sentencia_while " + "\n\t --> " + sw + " ");
            //concat_rules("Regla 3.1.1: sentencia --> " + sw);
            RESULT = sw; :}
        |
        sentencia_if:si {:
            concat_rules("REGLA 3.1.2: sentencia --> sentencia_if " + "\n\t --> " + si + " ");
            //concat_rules("Regla 3.1.2: sentencia --> " + si);
            RESULT = si; :}
        |
        sentencia_display:sd {:
            concat_rules("REGLA 3.1.3: sentencia --> sentencia_display " + "\n\t --> " + sd + " ");
            //concat_rules("Regla 3.1.3: sentencia --> " + sd);
            RESULT = sd; :}
        |
        sentencia_asignacion:sa{:
            concat_rules("REGLA 3.1.5: sentencia --> sentencia_asignacion " + "\n\t --> " + sa + " ");
            //concat_rules("Regla 3.1.5: sentencia --> " + sa);
            RESULT = sa;
        :};

sentencia_while ::=
        WHILE PARENTESISO exp_or:c PARENTESISC DO lista_sentencias:ls END {:
            concat_rules("REGLA 4: sentencia_while --> WHILE PARENTESISO exp_or PARENTESISC DO lista_sentencias END " + "\n\t --> " + "while ( " + c + " ) do" + ls + "end" + " " );
            //concat_rules("Regla 4: sentencia_while --> while (" + c + ") do" + ls + "end" );
            //RESULT = "while" + "(" + c + ")" + "do" + ls + "end";
            RESULT = new While("While",c,ls);
        :};

sentencia_if ::=
        if_simple:ifs {:
            concat_rules("REGLA 5: sentencia_if --> if_simple " + "\n\t --> " + ifs + " ");
            //concat_rules("Regla 5: sentencia_if --> " + ifs );
            RESULT = ifs;
         :}
        |
        if_else:ie {:
            concat_rules("REGLA 5: sentencia_if --> if_else " + "\n\t --> " + ie + " ");
            //concat_rules("Regla 5: sentencia_if --> " + ie );
            RESULT = ie;
         :};
if_simple ::=
        IF PARENTESISO exp_or:cond PARENTESISC THEN lista_sentencias:ls END {:
            concat_rules("REGLA 5.1: if_simple --> IF PARENTESISO exp_or PARENTESISC THEN lista_sentencias END " + "\n\t --> " + " if ( " + cond + " ) then " + ls + " end ");
            //concat_rules("Regla 5.1: if_simple --> if (" + cond + ") then " + ls + " end"  );
            //RESULT = "if " + " ( " + cond + " ) " +  " then " + ls + " end";
            RESULT = new IfSimple("IfSimple", cond, ls);
        :};
if_else ::=
        IF PARENTESISO exp_or:cond PARENTESISC THEN lista_sentencias:ls ELSE lista_sentencias:ls2 END {:
            concat_rules("REGLA 5.2: if_else --> IF PARENTESISO exp_or PARENTESISC THEN lista_sentencias ELSE lista_sentencias END " + "\n\t --> " + "if ( " + cond + " ) then " + ls + " else " + ls2 + "end ");
            //concat_rules("Regla 5.2: if_else --> if (" + cond + ") then" + ls + "else" + ls2 + "end"  );
            //RESULT = "if" + "(" + cond + ")" +  "then" + ls + "else" + ls2 + "end";
            RESULT = new IfElse("IfElse", cond, ls, ls2);
        :};

sentencia_display ::=
        DISPLAY PARENTESISO STRING_LITERAL:sl PARENTESISC {:
            concat_rules("REGLA 6: sentencia_display --> DISPLAY ( STRING_LITERAL ) " + "\n\t --> " + " display( " +sl+ " ) ");
            //concat_rules("Regla 6: sentencia_display --> "+ "display( " +sl+ " )");
            //RESULT = "display(" + sl + ")";
            ConstanteString CC = new ConstanteString(sl, Tipo.CTE_STRING, "CC");
            RESULT = new DisplayCadenaCaracteres(CC);
        :}
        |
        DISPLAY PARENTESISO exp_or:c PARENTESISC {:
            concat_rules("REGLA 6: sentencia_display --> DISPLAY ( exp_or ) " + "\n\t --> " + " display( " + c + " ) ");
            //concat_rules("Regla 6: sentencia_display --> "+ "display( " + c + " )");
            //RESULT = "display(" + c + ")";
            RESULT = new DisplayExpresion("DisplayExpresion",c);
        :};

sentencia_asignacion ::=
    IDENTIFIER:id  ASIGN exp_or:eo {:
        concat_rules("REGLA 7: sentencia_asignacion --> IDENTIFIER ASIGN exp_or " + "\n\t --> " + id + " := " + eo);
        //concat_rules("REGLA 7: sentencia_asignacion --> "+ id + " := " + eo);
        if (!tablaSimbolos2.containsKey(id)){
                    throw new Exception("Variable " + id + " no declarada.");
                    }
         else {
            //checkTipos(id,eo); hacer esa funcion arriba.
            Collection e = tablaSimbolos2.get(id);
            String tipo = String.valueOf(e.stream().findFirst());
            if (tipo.contains("Int")){
            RESULT = new Asignacion(new Identificador(id, Tipo.Int),eo);
            }
            if (tipo.contains("Float")){RESULT = new Asignacion(new Identificador(id, Tipo.Float),eo);}
            if (tipo.contains("Bool")){RESULT = new Asignacion(new Identificador(id, Tipo.Bool),eo);}

            //RESULT=id + " := " + eo;
         }
        :};

exp_or ::=
    exp_or:e1 OR exp_and:e2 {:
        concat_rules("REGLA 7.1: exp_or --> exp_or OR exp_and " + "\n\t --> " + e1 + " OR "+ e2);
        //concat_rules("REGLA 7.1: exp_or --> "+e1+ " OR "+ e2 );
        RESULT = new OR("OR",Tipo.Bool,e1,e2);
        //RESULT = e1+" OR "+e2 ;
    :}
    |
    exp_and:e {:
        concat_rules("REGLA 7.2: exp_or --> exp_and " + "\n\t --> " + e);
        //concat_rules("REGLA 7.2: exp_or --> "+e );
        RESULT = e ;
    :};

exp_and ::=
    exp_and:e1 AND exp_not:e2 {:
        concat_rules("REGLA 7.3: exp_and --> exp_and AND exp_not " + "\n\t --> " + e1+ " AND "+ e2);
        //concat_rules("REGLA 7.3: exp_and --> "+e1+ " AND "+ e2 );
        //RESULT = e1+" AND "+e2 ;
        RESULT = new AND("AND",Tipo.Bool,e1,e2);
    :}
    |
    exp_not:e {:
        concat_rules("REGLA 7.4: exp_and --> exp_not " + "\n\t --> " +e);
        //concat_rules("REGLA 7.4: exp_or --> "+e );
        RESULT = e ;
    :};

exp_not ::=
    NOT exp_not:e1 {:
        concat_rules("REGLA 7.5: exp_not --> NOT exp_not " + "\n\t --> " + e1);
        //concat_rules("REGLA 7.5: exp_not --> "+e1 );
        //RESULT = e1 ;
        RESULT = new NOT("NOT",e1,e1.getTipo());
    :}
    |
    comparacion:c {:
        concat_rules("REGLA 7.6: exp_not --> comparacion " + "\n\t --> " + c);
        //concat_rules("REGLA 7.6: exp_not --> "+c );
        RESULT = c ;
    :};

comparacion ::=
    expresion:e1 MAYOR:m expresion:e2{:
        concat_rules("REGLA 7.6.1: comparacion --> expresion MAYOR expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
        RESULT = new Mayor(">",Tipo.Bool,e1,e2);
    :}
    |
    expresion:e1 MENOR:m expresion:e2{:
            concat_rules("REGLA 7.6.1.1: comparacion --> expresion MENOR expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new Menor("<",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 IGUAL:m expresion:e2{:
            concat_rules("REGLA 7.6.1: comparacion --> expresion IGUAL expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new Igual("==",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 DISTINTO:m expresion:e2{:
            concat_rules("REGLA 7.6.1: comparacion --> expresion DISTINTO expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new Distinto("!=",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 MAYOR_IGUAL:m expresion:e2{:
            concat_rules("REGLA 7.6.1: comparacion --> expresion MAYOR_IGUAL expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new MayorOIgual(">=",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 MENOR_IGUAL:m expresion:e2{:
            concat_rules("REGLA 7.6.1: comparacion --> expresion MENOR_IGUAL expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new MenorOIgual("<=",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 {:
        concat_rules("REGLA 7.6.2: comparacion --> expresion " + "\n\t --> " + e1);
        //concat_rules("REGLA 7.6.2: comparacion --> "+e1);
        RESULT = e1 ;
    :};


expresion ::=
    expresion:e1 SUMA termino:e2 {:
        concat_rules("REGLA 7.7: expresion --> expresion SUMA termino " + "\n\t --> " + e1 +" + "+ e2);
        //concat_rules("REGLA 7.7: expresion --> "+e1+" + "+e2);
        //RESULT = new Suma(e1,e2);
        RESULT = new Suma("+",e1,e2) ;
    :}
    |
    expresion:e1 RESTA termino:e2 {:
        concat_rules("REGLA 7.8: expresion --> expresion RESTA termino " + "\n\t --> " + e1 + " - " + e2);
        //concat_rules("REGLA 7.8: expresion --> "+e1+" - "+e2);
        RESULT = new Resta("-",e1,e2) ;
    :}
    |
    termino:t {:
        concat_rules("REGLA 7.9: expresion --> termino " + "\n\t --> " + t);
        //concat_rules("REGLA 7.9: expresion --> "+ t );
        RESULT = t ;
    :};

termino ::=
    termino:t MULT menos_unario:mu {:
        concat_rules("REGLA 7.9.1: termino --> termino MULT menor_unario " + "\n\t --> " + t + " * " + mu);
        //concat_rules("REGLA 7.9.1: termino --> " + t + " * " + mu );
        RESULT = new Multiplicacion("*",t,mu) ; ;
    :}
    |
    termino:t DIV menos_unario:mu {:
        concat_rules("REGLA 7.9.2: termino --> termino DIV menor_unario " + "\n\t --> " + t + " / " + mu);
        //concat_rules("REGLA 7.9.2: termino --> " + t + " / " + mu );
        RESULT = new Division("/",t,mu);
    :}
    |
    menos_unario:mu {:
        concat_rules("REGLA 7.9.3: termino --> menor_unario " + "\n\t --> " + mu);
        //concat_rules("REGLA 7.9.3: termino --> " + mu );
        RESULT = mu;
    :};

menos_unario ::=
    RESTA menos_unario:mu {:
        concat_rules("REGLA 8.1: menos_unario --> - menor_unario " + "\n\t --> " + "- " +mu);
        //concat_rules("REGLA 8.1: menos_unario --> -" + mu );
        RESULT = new MenosUnario("MenosUnario", mu,mu.getTipo());

    :}
    |
    factor:f {: //superFenelchat
        concat_rules("REGLA 8.2: menos_unario --> factor " + "\n\t --> " + f);
        //concat_rules("REGLA 8.2: menos_unario --> " + f );
        RESULT = f;
    :};

factor ::=
    INT:i {:
        concat_rules("REGLA 8.1: factor --> INT " + "\n\t --> " + i);
        //concat_rules("REGLA 8.1: factor --> " + i );
        RESULT = new ConstanteEntera(i, Tipo.Int, "Factor_Int");
    :}
    |
    FLOAT:f {:
        concat_rules("REGLA 8.2: factor --> FLOAT " + "\n\t --> " + f);
        //concat_rules("REGLA 8.2: factor --> " + f );
        RESULT = new ConstanteFloat(f, Tipo.Float, "Factor_Float");
    :}
    |
    BOOL:b {:
        concat_rules("REGLA 8.3: factor --> BOOL " + "\n\t --> " + b);
        //concat_rules("REGLA 8.3: factor --> " + b );
        RESULT = new ConstanteBool(b, Tipo.Bool, "Factor_Bool");
    :}
    |
    funcion_especial:fe {:
        concat_rules("REGLA 8.4: factor --> funcion_especial " + "\n\t --> " + fe);
        //concat_rules("REGLA 8.4: factor --> " + fe );
        RESULT = fe;
    :}
    |
    PARENTESISO exp_or:eo PARENTESISC {:
        concat_rules("REGLA 8.5: factor --> PARENTESISO exp_or PARENTESISC " + "\n\t --> " + " ( " + eo + " ) ");
        //concat_rules("REGLA 8.5: factor --> " + "(" + eo + ")" );
        RESULT = eo;
    :}
    |
    IDENTIFIER:id {:
        concat_rules("REGLA 8.6: factor --> IDENTIFIER " + "\n\t --> " + id + " ");
        //concat_rules("REGLA 8.6: factor --> " + id );
        //RESULT = id;
        if (!tablaSimbolos2.containsKey(id)){
                            throw new Exception("Variable " + id + " no declarada.");
                            }
                 else {
        Collection e = tablaSimbolos2.get(id);
        String tipo = String.valueOf(e.stream().findFirst());
        if (tipo.contains("Int")){RESULT = new Identificador(id,Tipo.Int);}
        if (tipo.contains("Float")){RESULT = new Identificador(id, Tipo.Float);}
        if (tipo.contains("Bool")){RESULT = new Identificador(id, Tipo.Bool);}
        }
    :}
    |
    INPUT_BOOL:ib PARENTESISO PARENTESISC {:
        concat_rules("REGLA 8.7: factor --> INPUT_BOOL() " + "\n\t --> " + ib + "()");
        //concat_rules("REGLA 8.7: factor --> " + ib + "()" );
        RESULT = new Input_Bool(Tipo.Bool,"INPUT_BOOL");
    :}
    |
    INPUT_INT:ii PARENTESISO PARENTESISC {:
        concat_rules("REGLA 8.8: factor --> INPUT_INT() " + "\n\t --> " + ii + "()");
        //concat_rules("REGLA 8.8: factor --> " + ii + "()" );
        RESULT = new Input_Int("INPUT_INT", Tipo.Int);
    :}
    |
    INPUT_FLOAT:ifl PARENTESISO PARENTESISC {:
        concat_rules("REGLA 8.9: factor --> INPUT_FLOAT() " + "\n\t --> " + ifl + "()");
        //concat_rules("REGLA 8.9: factor --> " + ifl + "()" );
        RESULT = new Input_Float(Tipo.Float, "INPUT_FLOAT");
    :}    ;

funcion_especial ::=
    COLA PARENTESISO pivot:p PUNTOCOMA CORCHETEO lista_expresiones:le CORCHETEC PARENTESISC
    {:
        concat_rules("REGLA 9: funcion_especial --> COLA PARENTESISO pivot PUNTOCOMA CORCHETEO lista_expresiones CORCHETEC PARENTESISC " + "\n\t --> " + "cola ( " + p + " ;[ " + le + "])");
        //concat_rules("REGLA 9: factor --> " + "cola( " + p + " ;[ " + le + "])"   );
        //RESULT = "cola( "+p+";["+le+"])"  ;
        List<Sentencia> sents = new Arraylu
        Integer pos = 0;
                for (Expresion e:le)
                {
                    //Mayor m = new Mayor("Mayor", p,0);
                    Integer i = le.size();
                    String a = i.toString();
                    ConstanteEntera cc = new ConstanteEntera("LenLista", a);
                    Resta r = new Resta("Resta", cc,p);
                    String pos_String = pos.toString();
                    //ConstanteEntera posID = new ConstanteEntera(pos_String,"ID_pos");
                    Identificador pos1 = new Identificador("ID_pos",Tipo.Int);
                    Igual cond = new Igual("Igual", r,pos1);
                    MenorOIgual moi = new MenorOIgual("MenorOIgual", p, cc);
                    AND and_c = new AND("AND", cond, moi);
                    Identificador acum = new Identificador("acum");
                    Suma suma = new Suma("Suma", acum,e);
                    Asignacion asig1 = new Asignacion("Asignacion", acum, suma );
                    Suma sum = new Suma("Suma", pos1, new ConstanteEntera("1","Constante_Entera"));
                    Asignacion asig2 = new Asignacion("Asignacion", pos1, sum);
                    Resta resta = new Resta("Resta", p, new ConstanteEntera("1","Constante_Entera"));
                    Identificador pivot = new Identificador("pivot");
                    Asignacion asig3 = new Asignacion("Asignacion", pivot, resta);
                    List<Sentencia> sentencias1 = new ArrayList<>();
                    sentencias1.add(asig1);
                    sentencias1.add(asig2);
                    sentencias1.add(asig3);
                    /* ---------------------------------- --------------------------------------------- */
                    Suma sum2 = new Suma("Suma", pos1, new ConstanteEntera("1","Constante_Entera"));
                    Asignacion asig4 = new Asignacion("Asignacion", pos1, sum2);
                    List<Sentencia> sentencias2 = new ArrayList<>();
                    sentencias2.add(asig4);
                    IfElse ie = new IfElse("IFELSE", and_c,sentencias1, sentencias2);
                    RESULT=new Cola(ie);
                    pos++;
                }
    :};

pivot ::=
    IDENTIFIER:id {:
        concat_rules("REGLA 10: pivot --> IDENTIFIER " + "\n\t --> " + id);
        //concat_rules("REGLA 10: pivot --> " + id );
        RESULT = new Identificador("Pivot");
    :}
    |
    INT:i {:
        concat_rules("REGLA 10.1: pivot --> INT " + "\n\t --> " + i);
        //concat_rules("REGLA 10.1: pivot --> " + i );
        RESULT = i;
    :};

lista_expresiones ::=
    expresion:e {:
        concat_rules("REGLA 10.2: lista_expresiones --> expresion " + "\n\t --> " + e);
        //concat_rules("REGLA 10.1: lista_expresiones --> " + e );
        //RESULT = e;
        List<Expresion> lista_expresiones = new ArrayList<>();
        lista_expresiones.add(e);
        RESULT = lista_expresiones;
    :}
    |
    lista_expresiones:le COMA expresion:e{:
        concat_rules("REGLA 10.3: lista_expresiones --> lista_expresiones COMA expresion " + "\n\t --> " + le + ", " + e);
        //concat_rules("REGLA 10.3: lista_expresiones --> " +le+ ", " + e );
        //RESULT = le+", " + e;
        le.add(e);
        RESULT = le;
    :}
    |
    //puede ser vacia agregado
    ;