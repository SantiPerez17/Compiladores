package archivos.sintactico;

import archivos.ast.Base.Constantes.ConstanteBool;
import archivos.ast.Base.Constantes.ConstanteEntera;
import archivos.ast.Base.Constantes.ConstanteFloat;
import archivos.ast.Base.Constantes.ConstanteString;
import archivos.ast.Base.Expresiones.Expresion;
import archivos.ast.Base.Expresiones.FuncionEspecial.Cola;
import archivos.ast.Base.Expresiones.Inputs.Input_Bool;
import archivos.ast.Base.Expresiones.Inputs.Input_Float;
import archivos.ast.Base.Expresiones.Inputs.Input_Int;
import archivos.ast.Base.Expresiones.Operaciones.binarias.arismeticos.Division;
import archivos.ast.Base.Expresiones.Operaciones.binarias.arismeticos.Multiplicacion;
import archivos.ast.Base.Expresiones.Operaciones.binarias.arismeticos.Resta;
import archivos.ast.Base.Expresiones.Operaciones.binarias.arismeticos.Suma;
import archivos.ast.Base.Expresiones.Operaciones.binarias.comparaciones.*;
import archivos.ast.Base.Expresiones.Operaciones.binarias.logicas.AND;
import archivos.ast.Base.Expresiones.Operaciones.binarias.logicas.OR;
import archivos.ast.Base.Expresiones.Operaciones.unarias.MenosUnario;
import archivos.ast.Base.Expresiones.Operaciones.unarias.NOT;
import archivos.ast.Base.Expresiones.Operaciones.unarias.conversiones.EnteroAFlotante;
import archivos.ast.Base.Identificador;
import archivos.ast.Base.Nodo;
import archivos.ast.Base.Programa;
import archivos.ast.Base.Tipo;
import archivos.ast.Sentencias.Asignacion;
import archivos.ast.Sentencias.Displays.DisplayCadenaCaracteres;
import archivos.ast.Sentencias.Displays.DisplayExpresion;
import archivos.ast.Sentencias.Sentencia;
import archivos.ast.Sentencias.SentenciaInteraciones.While;
import archivos.ast.Sentencias.SentenciaSeleccion.IfElse;
import archivos.ast.Sentencias.SentenciaSeleccion.IfSimple;
import java_cup.runtime.Symbol;
import java.util.*;

class MiParser;


action code {:
    //Hashtable tablaSimbolo = new Hashtable();
    //Multimap<String, String> tablaSimbolos2 = ArrayListMultimap.create();
    //public Multimap getTabladeSimbolos(){
     //       return tablaSimbolos2;
   // }


    //public String simbolos;

:};

parser code
{:
    public void syntax_error(Symbol s) {
                    if (s.sym==32){
                                concat_rules("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
                                        +s.value+"' . Simbolo n° "+s.sym);
                        try {
                            throw new Exception((String) s.value);
                        } catch (Exception e) {

                        }
                    }
                            else
                            {concat_rules("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
                                    +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );}
            }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        if (s.sym == 32){
            throw  new Exception("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
                    +s.value+"' . Simbolo n° "+s.sym+ "" );
        }
        else
                                    {throw new Exception("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
                                            +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." ); }
    }

    public String reglas;

    public void concat_rules(String regla){
        reglas += regla + "\n\n";
    }

    public StringBuilder simbolos=new StringBuilder("");
    TreeMap<String, ArrayList<String>> tablaSimbolos2 = new TreeMap<String, ArrayList<String>>();

   public Tipo tipo_en_comun(Tipo t1,Tipo t2) throws java.lang.Exception
          {
              if (t1 == t2){
                  return t1;
              }
              if (t1==Tipo.Float && t2==Tipo.Int) {
                  return t1;
              }
              if (t1==Tipo.Int && t2==Tipo.Float) {
                  return t2;
              }
              throw new Exception(String.format("No existe un tipo común entre %1$s y %2$s\n", t1, t2 ));
          }
       private static Expresion convertir_a_tipo(Expresion expresion, Tipo tipo_destino) throws java.lang.Exception{
              Tipo tipo_origen = expresion.getTipo();
              if(tipo_origen == tipo_destino){
                  return expresion;
              }
              if(tipo_origen == Tipo.Int && tipo_destino == Tipo.Float){
                  return new EnteroAFlotante(expresion);
              }
              throw new Exception(String.format("No existe un tipo común entre %1$s y %2$s\n", tipo_origen, tipo_destino ));
          }

    private static void tipo_bool(Tipo tipo) throws Exception{
        if (tipo == Tipo.Bool){
            throw new Exception("No se permiten tipos booleanos en operaciones arismeticas.");
        }
    }
:};

terminal SUMA,RESTA,MULT,DIV, ASIGN, PARENTESISO, PARENTESISC, CORCHETEO, CORCHETEC, PUNTOCOMA,
COMA, DOSPUNTOS, DISPLAY, WHILE, DO, INPUT_INT, INPUT_FLOAT,INPUT_BOOL, IF, THEN, ELSE, END, AND, OR, NOT, MAYOR,MENOR,IGUAL,DISTINTO,MAYOR_IGUAL,MENOR_IGUAL, COLA, ERROR,TIPO_INT, TIPO_FLOAT, TIPO_BOOL;
terminal String STRING_LITERAL,BOOL, INT, FLOAT, IDENTIFIER,DECLARE_SECTION, ENDDECLARE_SECTION, PROGRAM_SECTION, ENDPROGRAM_SECTION;

nonterminal Nodo program;
nonterminal Programa programa;
nonterminal Tipo tipo_de_dato;
nonterminal Sentencia sentencia, sentencia_if, sentencia_display;
nonterminal List<Sentencia> lista_sentencias;
nonterminal While sentencia_while;
nonterminal Asignacion sentencia_asignacion;
nonterminal IfSimple if_simple;
nonterminal IfElse if_else;
nonterminal Expresion expresion, factor, menos_unario, termino, comparacion, exp_or,exp_and,exp_not, funcion_especial,pivot;
nonterminal String ids, sector_declaraciones,lista_declaraciones, declaracion;
nonterminal List<Expresion> lista_expresiones;
//precedence left OPCOMP, sentencia;

start with program;

program ::= sector_declaraciones:sd programa:p //programa
    {:  concat_rules("REGLA 0: program --> sector_declaraciones programa" + "\n\t --> " + sd + " " + p + " ");
    RESULT = p;
    //RESULT= sd + p ;
    :}
    |
    programa:p {:
    concat_rules("REGLA 0.1: program --> programa " + "\n\t --> " + p );
    RESULT = p;
    :}
    |;
sector_declaraciones ::= DECLARE_SECTION lista_declaraciones:ld ENDDECLARE_SECTION
    {: concat_rules("REGLA 1: sector_declaraciones --> DECLARE_SECTION lista_declaraciones ENDDECLARE_SECTION " + "\n\t --> " + "declare.section" + " " + ld + " " + "enddeclare.section" );
       RESULT = "DECLARE_SECTION" + ld + "ENDDECLARE_SECTION"; :};

lista_declaraciones ::= declaracion:d {:
    concat_rules ( "REGLA 1.1: lista_declaraciones --> declaracion " + "\n\t --> " + d + " ");
    RESULT = d; :}
    |
    lista_declaraciones:ld declaracion:d {:
    concat_rules ("REGLA 1.2: lista_declaraciones --> lista_declaraciones declaracion " + "\n\t --> " + " " + ld + d );
    RESULT = ld + d ; :};

declaracion ::= //no es necesario generar el nodo este.
    tipo_de_dato:td DOSPUNTOS ids:i PUNTOCOMA {:
        concat_rules("REGLA 2: declaracion --> tipo_de_dato DOSPUNTOS ids PUNTOCOMA " + "\n\t --> " + td + ": " + i + "; ");
        RESULT = td + ":" + i + ";";
        if (i.contains(",")){
        String[] parts = i.split(",");
        for (String s : parts){
            if (tablaSimbolos2.containsKey(s)){
                throw new Exception("Variable " + s + " ya declarada." );
                }
            else{
                ArrayList<String> hg = new ArrayList<String>(Arrays.asList("ID",td.name(),"_","_"));
                tablaSimbolos2.put(s,hg);
                simbolos.append(String.format("%20s%20s%20s%20s%20s%n", s, hg.get(0), hg.get(1), hg.get(2), hg.get(3)));}}}
        else{
            ArrayList<String> hg = new ArrayList<String>(Arrays.asList("ID",td.name(),"_","_"));
            tablaSimbolos2.put(i,hg);
            simbolos.append(String.format("%20s%20s%20s%20s%20s%n", i, hg.get(0), hg.get(1), hg.get(2), hg.get(3)));
        }
                //para traer Tipo de la tabla de simbolos
                        // String t = tablaSimbolos2.get(i).stream().findFirst().get();
                //simbolos = new StringBuilder(tablaSimbolos2.toString() + "\n\n");
                //RESULT = new DeclaracionVariable( id, td) ; PREGUNTAR ESO
        :};

ids ::=
    IDENTIFIER:id {:
        concat_rules("REGLA 2.2: ids --> IDENTIFIER " + "\n\t --> " + id);
        RESULT = id; :}
    |
    ids:i COMA IDENTIFIER:id {:
        concat_rules("REGLA 2.2: ids --> ids IDENTIFIER " + "\n\t --> " + i + ", "+ id);
        RESULT = i + "," + id; :};

tipo_de_dato ::=
    TIPO_INT:ti {:
        concat_rules("REGLA 2.2.1: tipo_de_dato --> TIPO_INT " + "\n\t --> " + ti);
        //concat_rules("Regla 2.2.1: tipo_de_dato -->" + ti );
        RESULT = Tipo.Int; :}
    |
    TIPO_FLOAT:tf {:
        concat_rules("REGLA 2.2.2: tipo_de_dato --> TIPO_FLOAT " + "\n\t --> " + tf);
        //concat_rules("Regla 2.2.2: tipo_de_dato -->" + tf );
        RESULT = Tipo.Float; :}
    |
    TIPO_BOOL:tb {:
        concat_rules("REGLA 2.2.3: tipo_de_dato --> TIPO_BOOL " + "\n\t --> " + tb);
        //concat_rules("Regla 2.2.3: tipo_de_dato --> "+ tb);
        RESULT = Tipo.Bool;:};

programa ::=
        PROGRAM_SECTION lista_sentencias:ls ENDPROGRAM_SECTION {:
            concat_rules("REGLA 3: programa --> PROGRAM_SECTION lista_sentencias ENDPROGRAM_SECTION " + "\n\t --> " + "program.section " + ls  + " endprogram.section");
            //concat_rules("Regla 3: programa --> program.section " + ls  + " endprogram.section");
            //RESULT = "PROGRAM_SECTION" + ls + "ENDPROGRAM_SECTION";
            RESULT = new Programa("Programa", tablaSimbolos2, ls);

        :};

lista_sentencias ::=
        sentencia:s {:
            concat_rules("REGLA 3.1: lista_sentencias --> sentencia " + "\n\t --> " + s + " ");
            //concat_rules("Regla 3.1: lista_sentencias --> "  + s);
            List<Sentencia> lista_sentencias = new ArrayList<>();
            lista_sentencias.add(s);
            RESULT = lista_sentencias; :}
        |
        lista_sentencias:ls sentencia:s {:
            concat_rules("REGLA 3.2: lista_sentencias --> lista_sentencias sentencia " + "\n\t --> " + ls + " " + s + " ");
            //concat_rules("Regla 3.2: lista_sentencias --> " + ls + s);
            ls.add(s);
            RESULT = ls; :};

sentencia ::=
        sentencia_while:sw {:
            concat_rules("REGLA 3.1.1: sentencia --> sentencia_while " + "\n\t --> " + sw + " ");
            //concat_rules("Regla 3.1.1: sentencia --> " + sw);
            RESULT = sw; :}
        |
        sentencia_if:si {:
            concat_rules("REGLA 3.1.2: sentencia --> sentencia_if " + "\n\t --> " + si + " ");
            //concat_rules("Regla 3.1.2: sentencia --> " + si);
            RESULT = si; :}
        |
        sentencia_display:sd {:
            concat_rules("REGLA 3.1.3: sentencia --> sentencia_display " + "\n\t --> " + sd + " ");
            //concat_rules("Regla 3.1.3: sentencia --> " + sd);
            RESULT = sd; :}
        |
        sentencia_asignacion:sa{:
            concat_rules("REGLA 3.1.5: sentencia --> sentencia_asignacion " + "\n\t --> " + sa + " ");
            //concat_rules("Regla 3.1.5: sentencia --> " + sa);
            RESULT = sa;
        :};

sentencia_while ::=
        WHILE PARENTESISO exp_or:c PARENTESISC DO lista_sentencias:ls END {:
            concat_rules("REGLA 4: sentencia_while --> WHILE PARENTESISO exp_or PARENTESISC DO lista_sentencias END " + "\n\t --> " + "while ( " + c + " ) do" + ls + "end" + " " );
            //concat_rules("Regla 4: sentencia_while --> while (" + c + ") do" + ls + "end" );
            //RESULT = "while" + "(" + c + ")" + "do" + ls + "end";
            RESULT = new While("While",c,ls);
        :};

sentencia_if ::=
        if_simple:ifs {:
            concat_rules("REGLA 5: sentencia_if --> if_simple " + "\n\t --> " + ifs + " ");
            //concat_rules("Regla 5: sentencia_if --> " + ifs );
            RESULT = ifs;
         :}
        |
        if_else:ie {:
            concat_rules("REGLA 5: sentencia_if --> if_else " + "\n\t --> " + ie + " ");
            //concat_rules("Regla 5: sentencia_if --> " + ie );
            RESULT = ie;
         :};
if_simple ::=
        IF PARENTESISO exp_or:cond PARENTESISC THEN lista_sentencias:ls END {:
            concat_rules("REGLA 5.1: if_simple --> IF PARENTESISO exp_or PARENTESISC THEN lista_sentencias END " + "\n\t --> " + " if ( " + cond + " ) then " + ls + " end ");
            //concat_rules("Regla 5.1: if_simple --> if (" + cond + ") then " + ls + " end"  );
            //RESULT = "if " + " ( " + cond + " ) " +  " then " + ls + " end";
            RESULT = new IfSimple("IfSimple", cond, ls);
        :};
if_else ::=
        IF PARENTESISO exp_or:cond PARENTESISC THEN lista_sentencias:ls ELSE lista_sentencias:ls2 END {:
            concat_rules("REGLA 5.2: if_else --> IF PARENTESISO exp_or PARENTESISC THEN lista_sentencias ELSE lista_sentencias END " + "\n\t --> " + "if ( " + cond + " ) then " + ls + " else " + ls2 + "end ");
            //concat_rules("Regla 5.2: if_else --> if (" + cond + ") then" + ls + "else" + ls2 + "end"  );
            //RESULT = "if" + "(" + cond + ")" +  "then" + ls + "else" + ls2 + "end";
            RESULT = new IfElse("IfElse", cond, ls, ls2);
        :};

sentencia_display ::=
        DISPLAY PARENTESISO STRING_LITERAL:sl PARENTESISC {:
            concat_rules("REGLA 6: sentencia_display --> DISPLAY ( STRING_LITERAL ) " + "\n\t --> " + " display( " +sl+ " ) ");
            //concat_rules("Regla 6: sentencia_display --> "+ "display( " +sl+ " )");
            //RESULT = "display(" + sl + ")";
            //tablaSimbolos2.put(sl,Tipo.CTE_STRING.name());
            ArrayList<String> hg = new ArrayList<String>(
                Arrays.asList("STRING_LITERAL",Tipo.CTE_STRING.name(),sl,String.valueOf(sl.length())));
            tablaSimbolos2.put(" ",hg);
            simbolos.append(String.format("%20s%20s%20s%20s%20s%n","_", hg.get(0), hg.get(1), hg.get(2), hg.get(3)));
            ConstanteString CC = new ConstanteString(sl, Tipo.CTE_STRING, "CC");
            RESULT = new DisplayCadenaCaracteres(CC);
        :}
        |
        DISPLAY PARENTESISO exp_or:c PARENTESISC {:
            concat_rules("REGLA 6: sentencia_display --> DISPLAY ( exp_or ) " + "\n\t --> " + " display( " + c + " ) ");
            //concat_rules("Regla 6: sentencia_display --> "+ "display( " + c + " )");
            //RESULT = "display(" + c + ")";
            RESULT = new DisplayExpresion("DisplayExpresion",c);
        :};

sentencia_asignacion ::=
    IDENTIFIER:id  ASIGN exp_or:eo {:
        concat_rules("REGLA 7: sentencia_asignacion --> IDENTIFIER ASIGN exp_or " + "\n\t --> " + id + " := " + eo);
        //concat_rules("REGLA 7: sentencia_asignacion --> "+ id + " := " + eo);
        if (!tablaSimbolos2.containsKey(id)){
            throw new Exception("Variable " + id + " no declarada.");
        }
        else {
            ArrayList<String> a = tablaSimbolos2.get(id);
            if (Objects.equals(a.get(1), "Int")){
                if (eo.getTipo() == Tipo.Float){
                    throw new Exception("No se admiten Asignaciones con un Identificador Tipo INT y una Expresion Tipo FLOAT");
                }
            else{
                Expresion exp = convertir_a_tipo(eo, Tipo.Int);
                RESULT = new Asignacion(new Identificador(id, Tipo.Int),exp);}}
            if (Objects.equals(a.get(1), "Float")){
                Expresion exp = convertir_a_tipo(eo, Tipo.Float);
                RESULT = new Asignacion(new Identificador(id, Tipo.Float),exp);}
            if (Objects.equals(a.get(1), "Bool")){
                Tipo tipo_comun = tipo_en_comun(Tipo.Bool,eo.getTipo());
                Expresion exp = convertir_a_tipo(eo, tipo_comun);
                RESULT = new Asignacion(new Identificador(id, Tipo.Bool),exp);}
            //RESULT=id + " := " + eo;
        }
        :};

exp_or ::=
    exp_or:e1 OR exp_and:e2 {:
        concat_rules("REGLA 7.1: exp_or --> exp_or OR exp_and " + "\n\t --> " + e1 + " OR "+ e2);
        //concat_rules("REGLA 7.1: exp_or --> "+e1+ " OR "+ e2 );
        RESULT = new OR("OR",Tipo.Bool,e1,e2);
        //RESULT = e1+" OR "+e2 ;
    :}
    |
    exp_and:e {:
        concat_rules("REGLA 7.2: exp_or --> exp_and " + "\n\t --> " + e);
        //concat_rules("REGLA 7.2: exp_or --> "+e );
        RESULT = e ;
    :};

exp_and ::=
    exp_and:e1 AND exp_not:e2 {:
        concat_rules("REGLA 7.3: exp_and --> exp_and AND exp_not " + "\n\t --> " + e1+ " AND "+ e2);
        //concat_rules("REGLA 7.3: exp_and --> "+e1+ " AND "+ e2 );
        //RESULT = e1+" AND "+e2 ;
        RESULT = new AND("AND",Tipo.Bool,e1,e2);
    :}
    |
    exp_not:e {:
        concat_rules("REGLA 7.4: exp_and --> exp_not " + "\n\t --> " +e);
        //concat_rules("REGLA 7.4: exp_or --> "+e );
        RESULT = e ;
    :};

exp_not ::=
    NOT exp_not:e1 {:
        concat_rules("REGLA 7.5: exp_not --> NOT exp_not " + "\n\t --> " + e1);
        //concat_rules("REGLA 7.5: exp_not --> "+e1 );
        //RESULT = e1 ;
        RESULT = new NOT("NOT",e1,Tipo.Bool);
    :}
    |
    comparacion:c {:
        concat_rules("REGLA 7.6: exp_not --> comparacion " + "\n\t --> " + c);
        //concat_rules("REGLA 7.6: exp_not --> "+c );
        RESULT = c ;
    :};

comparacion ::=
    expresion:e1 MAYOR:m expresion:e2{:
        concat_rules("REGLA 7.6.1: comparacion --> expresion MAYOR expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
        RESULT = new Mayor(">",Tipo.Bool,e1,e2);
    :}
    |
    expresion:e1 MENOR:m expresion:e2{:
            concat_rules("REGLA 7.6.1.1: comparacion --> expresion MENOR expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new Menor("<",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 IGUAL:m expresion:e2{:
            concat_rules("REGLA 7.6.1: comparacion --> expresion IGUAL expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new Igual("==",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 DISTINTO:m expresion:e2{:
            concat_rules("REGLA 7.6.1: comparacion --> expresion DISTINTO expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new Distinto("!=",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 MAYOR_IGUAL:m expresion:e2{:
            concat_rules("REGLA 7.6.1: comparacion --> expresion MAYOR_IGUAL expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new MayorOIgual(">=",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 MENOR_IGUAL:m expresion:e2{:
            concat_rules("REGLA 7.6.1: comparacion --> expresion MENOR_IGUAL expresion " + "\n\t --> " + e1 + " " + m + " " + e2);
            RESULT = new MenorOIgual("<=",Tipo.Bool,e1,e2);
        :}
    |
    expresion:e1 {:
        concat_rules("REGLA 7.6.2: comparacion --> expresion " + "\n\t --> " + e1);
        //concat_rules("REGLA 7.6.2: comparacion --> "+e1);
        RESULT = e1 ;
    :};


expresion ::=
    expresion:e1 SUMA termino:e2 {:
        concat_rules("REGLA 7.7: expresion --> expresion SUMA termino " + "\n\t --> " + e1 +" + "+ e2);
        //concat_rules("REGLA 7.7: expresion --> "+e1+" + "+e2);
        //RESULT = new Suma(e1,e2);
        Tipo tipo_comun = tipo_en_comun(e1.getTipo(),e2.getTipo());
        tipo_bool(tipo_comun);
        RESULT = new Suma("+",tipo_comun,convertir_a_tipo(e1,tipo_comun),convertir_a_tipo(e2,tipo_comun));
    :}
    |
    expresion:e1 RESTA termino:e2 {:
        concat_rules("REGLA 7.8: expresion --> expresion RESTA termino " + "\n\t --> " + e1 + " - " + e2);
        //concat_rules("REGLA 7.8: expresion --> "+e1+" - "+e2);
        Tipo tipo_comun = tipo_en_comun(e1.getTipo(),e2.getTipo());
        tipo_bool(tipo_comun);
        RESULT = new Resta("-",tipo_comun,convertir_a_tipo(e1,tipo_comun),convertir_a_tipo(e2,tipo_comun));
    :}
    |
    termino:t {:
        concat_rules("REGLA 7.9: expresion --> termino " + "\n\t --> " + t);
        //concat_rules("REGLA 7.9: expresion --> "+ t );
        RESULT = t ;
    :};

termino ::=
    termino:t MULT menos_unario:mu {:
        concat_rules("REGLA 7.9.1: termino --> termino MULT menor_unario " + "\n\t --> " + t + " * " + mu);
        //concat_rules("REGLA 7.9.1: termino --> " + t + " * " + mu );
        Tipo tipo_comun = tipo_en_comun(t.getTipo(),mu.getTipo());
        tipo_bool(tipo_comun);
        RESULT = new Multiplicacion("*",tipo_comun,convertir_a_tipo(t,tipo_comun),convertir_a_tipo(mu,tipo_comun));
    :}
    |
    termino:t DIV menos_unario:mu {:
        concat_rules("REGLA 7.9.2: termino --> termino DIV menor_unario " + "\n\t --> " + t + " / " + mu);
        //concat_rules("REGLA 7.9.2: termino --> " + t + " / " + mu );
        Tipo tipo_comun = tipo_en_comun(t.getTipo(),mu.getTipo());
        tipo_bool(tipo_comun);
        RESULT = new Division("/",tipo_comun,convertir_a_tipo(t,tipo_comun),convertir_a_tipo(mu,tipo_comun));
    :}
    |
    menos_unario:mu {:
        concat_rules("REGLA 7.9.3: termino --> menor_unario " + "\n\t --> " + mu);
        //concat_rules("REGLA 7.9.3: termino --> " + mu );
        RESULT = mu;
    :};

menos_unario ::=
    RESTA menos_unario:mu {:
        concat_rules("REGLA 8.1: menos_unario --> - menor_unario " + "\n\t --> " + "- " +mu);
        //concat_rules("REGLA 8.1: menos_unario --> -" + mu );
        RESULT = new MenosUnario("MenosUnario", mu,mu.getTipo());

    :}
    |
    factor:f {: //superFenelchat
        concat_rules("REGLA 8.2: menos_unario --> factor " + "\n\t --> " + f);
        //concat_rules("REGLA 8.2: menos_unario --> " + f );
        RESULT = f;
    :};

factor ::=
    INT:i {:
        concat_rules("REGLA 8.1: factor --> INT " + "\n\t --> " + i);
        //concat_rules("REGLA 8.1: factor --> " + i );
        RESULT = new ConstanteEntera(i, Tipo.Int, "Factor_Int");
    :}
    |
    FLOAT:f {:
        concat_rules("REGLA 8.2: factor --> FLOAT " + "\n\t --> " + f);
        //concat_rules("REGLA 8.2: factor --> " + f );
        RESULT = new ConstanteFloat(f, Tipo.Float, "Factor_Float");
    :}
    |
    BOOL:b {:
        concat_rules("REGLA 8.3: factor --> BOOL " + "\n\t --> " + b);
        //concat_rules("REGLA 8.3: factor --> " + b );
        RESULT = new ConstanteBool(b, Tipo.Bool, "Factor_Bool");
    :}
    |
    funcion_especial:fe {:
        concat_rules("REGLA 8.4: factor --> funcion_especial " + "\n\t --> " + fe);
        //concat_rules("REGLA 8.4: factor --> " + fe );
        RESULT = fe;
    :}
    |
    PARENTESISO exp_or:eo PARENTESISC {:
        concat_rules("REGLA 8.5: factor --> PARENTESISO exp_or PARENTESISC " + "\n\t --> " + " ( " + eo + " ) ");
        //concat_rules("REGLA 8.5: factor --> " + "(" + eo + ")" );
        RESULT = eo;
    :}
    |
    IDENTIFIER:id {:
        concat_rules("REGLA 8.6: factor --> IDENTIFIER " + "\n\t --> " + id + " ");
        //concat_rules("REGLA 8.6: factor --> " + id );
        //RESULT = id;
        if (!tablaSimbolos2.containsKey(id)){
            throw new Exception("Variable " + id + " no declarada.");
            }
        else {
            ArrayList<String> e = tablaSimbolos2.get(id);
            if (e.get(1)=="Int"){RESULT = new Identificador(id,Tipo.Int);}
            if (e.get(1)=="Float"){RESULT = new Identificador(id, Tipo.Float);}
            if (e.get(1)=="Bool"){RESULT = new Identificador(id, Tipo.Bool);}
        }
    :}
    |
    INPUT_BOOL:ib PARENTESISO PARENTESISC {:
        concat_rules("REGLA 8.7: factor --> INPUT_BOOL() " + "\n\t --> " + ib + "()");
        //concat_rules("REGLA 8.7: factor --> " + ib + "()" );
        RESULT = new Input_Bool(Tipo.Bool,"INPUT_BOOL");
    :}
    |
    INPUT_INT:ii PARENTESISO PARENTESISC {:
        concat_rules("REGLA 8.8: factor --> INPUT_INT() " + "\n\t --> " + ii + "()");
        //concat_rules("REGLA 8.8: factor --> " + ii + "()" );
        RESULT = new Input_Int("INPUT_INT", Tipo.Int);
    :}
    |
    INPUT_FLOAT:ifl PARENTESISO PARENTESISC {:
        concat_rules("REGLA 8.9: factor --> INPUT_FLOAT() " + "\n\t --> " + ifl + "()");
        //concat_rules("REGLA 8.9: factor --> " + ifl + "()" );
        RESULT = new Input_Float(Tipo.Float, "INPUT_FLOAT");
    :}    ;

funcion_especial ::=
    COLA PARENTESISO pivot:p PUNTOCOMA CORCHETEO lista_expresiones:le CORCHETEC PARENTESISC
    {:
        concat_rules("REGLA 9: funcion_especial --> COLA PARENTESISO pivot PUNTOCOMA CORCHETEO lista_expresiones CORCHETEC PARENTESISC " + "\n\t --> " + "cola ( " + p + " ;[ " + le + "])");
        //concat_rules("REGLA 9: factor --> " + "cola( " + p + " ;[ " + le + "])"   );
        //RESULT = "cola( "+p+";["+le+"])"  ;
        //hacer validaciones
         List<Sentencia> sents = new ArrayList<>();
                Integer pos = 0;
                for (Expresion e:le){
                    Integer i = le.size();
                    String a = i.toString();
                    String pos_String = pos.toString();
                    AND and_c = new AND("AND",Tipo.Bool, new Igual("Igual",Tipo.Bool, new Resta("Resta",Tipo.Int, new ConstanteEntera(a,Tipo.Int,"LenLista"),new Identificador("pivot",Tipo.Int)),new Identificador("ID_pos",Tipo.Int)), new MenorOIgual("MenorOIgual",Tipo.Bool, new Identificador("pivot", Tipo.Int), new ConstanteEntera(a,Tipo.Int,"LenLista")));
                    Asignacion asig1 = new Asignacion("Asignacion", new Identificador("acum",Tipo.Int), new Suma("Suma",Tipo.Int, new Identificador("acum",Tipo.Int),e));
                    Asignacion asig2 = new Asignacion("Asignacion", new Identificador("ID_pos",Tipo.Int), new Suma("Suma",Tipo.Int, new Identificador("ID_pos",Tipo.Int), new ConstanteEntera("1",Tipo.Int,"Constante_Entera")));
                    Asignacion asig3 = new Asignacion("Asignacion", new Identificador("pivot",Tipo.Int), new Resta("Resta",Tipo.Int, new Identificador("pivot",Tipo.Int), new ConstanteEntera("1",Tipo.Int,"Constante_Entera")));
                    List<Sentencia> sentencias1 = new ArrayList<>();
                    sentencias1.add(asig1);
                    sentencias1.add(asig2);
                    sentencias1.add(asig3);
                    /*                                   */
                    Asignacion asig4 = new Asignacion("Asignacion", new Identificador("ID_pos",Tipo.Int), new Suma("Suma",Tipo.Int, new Identificador("ID_pos",Tipo.Int), new ConstanteEntera("1", Tipo.Int,"Constante_Entera")));
                    List<Sentencia> sentencias2 = new ArrayList<>();
                    sentencias2.add(asig4);
                    IfElse ie = new IfElse("IFELSE", and_c,sentencias1, sentencias2);
                    sents.add(ie);
                    pos++;
                }
                RESULT=new Cola("Cola",Tipo.Int,sents);
    :};

pivot ::=
    IDENTIFIER:id {:
        concat_rules("REGLA 10: pivot --> IDENTIFIER " + "\n\t --> " + id);
        //concat_rules("REGLA 10: pivot --> " + id );
        if(tablaSimbolos2.containsKey(id)){
            RESULT = new Identificador("Pivot",Tipo.Int);
        }
        else{
            throw new Exception("Variable Pivot no declarada.");
        }
    :}
    |
    INT:i {:
        concat_rules("REGLA 10.1: pivot --> INT " + "\n\t --> " + i);
        //concat_rules("REGLA 10.1: pivot --> " + i );
        RESULT = new ConstanteEntera(i,Tipo.Int,"Pivot");
    :};

lista_expresiones ::=
    expresion:e {:
        concat_rules("REGLA 10.2: lista_expresiones --> expresion " + "\n\t --> " + e);
        //concat_rules("REGLA 10.1: lista_expresiones --> " + e );
        //RESULT = e;
        List<Expresion> lista_expresiones = new ArrayList<>();
        lista_expresiones.add(e);
        RESULT = lista_expresiones;
    :}
    |
    lista_expresiones:le COMA expresion:e{:
        concat_rules("REGLA 10.3: lista_expresiones --> lista_expresiones COMA expresion " + "\n\t --> " + le + ", " + e);
        //concat_rules("REGLA 10.3: lista_expresiones --> " +le+ ", " + e );
        //RESULT = le+", " + e;
        le.add(e);
        RESULT = le;
    :}
    |
    //puede ser vacia agregado
    ;